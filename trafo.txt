The function optimise does two passes over the AST. The first pass is to compose all occurences of Map as much as possible. This is achieved by 
traversing over the AST untill you find a Map . It then applies map_map2 to the result of the traversing the subtree. This ensures that 
as many functions can be composed at once.  A second pass eliminates Map by the same process, using lower_map2.

The function "app_fun'", which performs beta-reduction, was reused. In the case of substitution, it was used to bind the body of g, to the 
first variable in f. In the case of composition with a let binding, it was used to apply f to the variable generated by the let binding.

Aesthetically I prefer map_map1, but as let bindings share the result of computation in accelerate (I believe),
 I think map_map2 will produce better code.
